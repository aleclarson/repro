{"version":3,"file":"immer.js","sources":["../src/common.js","../src/scope.js","../src/es5.js","../src/proxy.js","../src/patches.js","../src/immer.js","../src/index.js"],"sourcesContent":["export const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const DRAFTABLE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol.for(\"immer-draftable\")\n        : \"__$immer_draftable\"\n\nexport const DRAFT_STATE =\n    typeof Symbol !== \"undefined\" ? Symbol.for(\"immer-state\") : \"__$immer_state\"\n\nexport function isDraft(value) {\n    return !!value && !!value[DRAFT_STATE]\n}\n\nexport function isDraftable(value) {\n    if (!value || typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    if (!proto || proto === Object.prototype) return true\n    return !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE]\n}\n\nexport function original(value) {\n    if (value && value[DRAFT_STATE]) {\n        return value[DRAFT_STATE].base\n    }\n    // otherwise return undefined\n}\n\nexport const assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport const ownKeys =\n    typeof Reflect !== \"undefined\" && Reflect.ownKeys\n        ? Reflect.ownKeys\n        : typeof Object.getOwnPropertySymbols !== \"undefined\"\n        ? obj =>\n              Object.getOwnPropertyNames(obj).concat(\n                  Object.getOwnPropertySymbols(obj)\n              )\n        : Object.getOwnPropertyNames\n\nexport function shallowCopy(base, invokeGetters = false) {\n    if (Array.isArray(base)) return base.slice()\n    const clone = Object.create(Object.getPrototypeOf(base))\n    ownKeys(base).forEach(key => {\n        if (key === DRAFT_STATE) {\n            return // Never copy over draft state.\n        }\n        const desc = Object.getOwnPropertyDescriptor(base, key)\n        if (desc.get) {\n            if (!invokeGetters) {\n                throw new Error(\"Immer drafts cannot have computed properties\")\n            }\n            desc.value = desc.get.call(base)\n        }\n        if (desc.enumerable) {\n            clone[key] = desc.value\n        } else {\n            Object.defineProperty(clone, key, {\n                value: desc.value,\n                writable: true,\n                configurable: true\n            })\n        }\n    })\n    return clone\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i], value)\n    } else {\n        ownKeys(value).forEach(key => cb(key, value[key], value))\n    }\n}\n\nexport function isEnumerable(base, prop) {\n    return Object.getOwnPropertyDescriptor(base, prop).enumerable\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","import {DRAFT_STATE} from \"./common\"\n\n/** Each scope represents a `produce` call. */\nexport class ImmerScope {\n    constructor(parent) {\n        this.drafts = []\n        this.parent = parent\n\n        // Whenever the modified draft contains a draft from another scope, we\n        // need to prevent auto-freezing so the unowned draft can be finalized.\n        this.canAutoFreeze = true\n\n        // To avoid prototype lookups:\n        this.patches = null\n    }\n    usePatches(patchListener) {\n        if (patchListener) {\n            this.patches = []\n            this.inversePatches = []\n            this.patchListener = patchListener\n        }\n    }\n    revoke() {\n        this.leave()\n        this.drafts.forEach(revoke)\n        this.drafts = null // Make draft-related methods throw.\n    }\n    leave() {\n        if (this === ImmerScope.current) {\n            ImmerScope.current = this.parent\n        }\n    }\n}\n\nImmerScope.current = null\nImmerScope.enter = function() {\n    return (this.current = new ImmerScope(this.current))\n}\n\nfunction revoke(draft) {\n    draft[DRAFT_STATE].revoke()\n}\n","\"use strict\"\nimport {\n    each,\n    has,\n    is,\n    isDraft,\n    isDraftable,\n    isEnumerable,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\nconst descriptors = {}\n\nexport function willFinalize(scope, result, isReplaced) {\n    scope.drafts.forEach(draft => {\n        draft[DRAFT_STATE].finalizing = true\n    })\n    if (!isReplaced) {\n        if (scope.patches) {\n            markChangesRecursively(scope.drafts[0])\n        }\n        // This is faster when we don't care about which attributes changed.\n        markChangesSweep(scope.drafts)\n    }\n    // When a child draft is returned, look for changes.\n    else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n        markChangesSweep(scope.drafts)\n    }\n}\n\nexport function createProxy(base, parent) {\n    const isArray = Array.isArray(base)\n    const draft = clonePotentialDraft(base)\n    each(draft, prop => {\n        proxyProperty(draft, prop, isArray || isEnumerable(base, prop))\n    })\n\n    // See \"proxy.js\" for property documentation.\n    const scope = parent ? parent.scope : ImmerScope.current\n    const state = {\n        scope,\n        modified: false,\n        finalizing: false, // es5 only\n        finalized: false,\n        assigned: {},\n        parent,\n        base,\n        draft,\n        copy: null,\n        revoke,\n        revoked: false // es5 only\n    }\n\n    createHiddenProperty(draft, DRAFT_STATE, state)\n    scope.drafts.push(draft)\n    return draft\n}\n\nfunction revoke() {\n    this.revoked = true\n}\n\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    assertUnrevoked(state)\n    const value = source(state)[prop]\n    // Drafts are only created for proxyable values that exist in the base state.\n    if (!state.finalizing && value === state.base[prop] && isDraftable(value)) {\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(value, state))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnrevoked(state)\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (!state.copy) state.copy = clonePotentialDraft(state.base)\n}\n\nfunction clonePotentialDraft(base) {\n    const state = base && base[DRAFT_STATE]\n    if (state) {\n        state.finalizing = true\n        const draft = shallowCopy(state.draft, true)\n        state.finalizing = false\n        return draft\n    }\n    return shallowCopy(base)\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n    let desc = descriptors[prop]\n    if (desc) {\n        desc.enumerable = enumerable\n    } else {\n        descriptors[prop] = desc = {\n            configurable: true,\n            enumerable,\n            get() {\n                return get(this[DRAFT_STATE], prop)\n            },\n            set(value) {\n                set(this[DRAFT_STATE], prop, value)\n            }\n        }\n    }\n    Object.defineProperty(draft, prop, desc)\n}\n\nfunction assertUnrevoked(state) {\n    if (state.revoked === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(source(state))\n        )\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(drafts) {\n    // The natural order of drafts in the `scope` array is based on when they\n    // were accessed. By processing drafts in reverse natural order, we have a\n    // better chance of processing leaf nodes first. When a leaf node is known to\n    // have changed, we can avoid any traversal of its ancestor nodes.\n    for (let i = drafts.length - 1; i >= 0; i--) {\n        const state = drafts[i][DRAFT_STATE]\n        if (!state.modified) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[DRAFT_STATE]\n    if (!state) return\n    const {base, draft, assigned} = state\n    if (!Array.isArray(object)) {\n        // Look for added keys.\n        Object.keys(draft).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (base[key] === undefined && !has(base, key)) {\n                assigned[key] = true\n                markChanged(state)\n            } else if (!assigned[key]) {\n                // Only untouched properties trigger recursion.\n                markChangesRecursively(draft[key])\n            }\n        })\n        // Look for removed keys.\n        Object.keys(base).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (draft[key] === undefined && !has(draft, key)) {\n                assigned[key] = false\n                markChanged(state)\n            }\n        })\n    } else if (hasArrayChanges(state)) {\n        markChanged(state)\n        assigned.length = true\n        if (draft.length < base.length) {\n            for (let i = draft.length; i < base.length; i++) assigned[i] = false\n        } else {\n            for (let i = base.length; i < draft.length; i++) assigned[i] = true\n        }\n        for (let i = 0; i < draft.length; i++) {\n            // Only untouched indices trigger recursion.\n            if (assigned[i] === undefined) markChangesRecursively(draft[i])\n        }\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const {base, draft} = state\n\n    // Search for added keys. Start at the back, because non-numeric keys\n    // are ordered by time of definition on the object.\n    const keys = Object.keys(draft)\n    for (let i = keys.length - 1; i >= 0; i--) {\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (base[keys[i]] === undefined && !has(base, keys[i])) {\n            return true\n        }\n    }\n\n    // Since no keys have been added, we can compare lengths to know if an\n    // object has been deleted.\n    return keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state) {\n    const {draft} = state\n    if (draft.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","\"use strict\"\nimport {\n    assign,\n    each,\n    has,\n    is,\n    isDraftable,\n    isDraft,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\n// Do nothing before being finalized.\nexport function willFinalize() {}\n\nexport function createProxy(base, parent) {\n    const scope = parent ? parent.scope : ImmerScope.current\n    const state = {\n        // Track which produce call this is associated with.\n        scope,\n        // True for both shallow and deep changes.\n        modified: false,\n        // Used during finalization.\n        finalized: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned: {},\n        // The parent draft state.\n        parent,\n        // The base state.\n        base,\n        // The base proxy.\n        draft: null,\n        // Any property proxies.\n        drafts: {},\n        // The base copy with any updated values.\n        copy: null,\n        // Called by the `produce` function.\n        revoke: null\n    }\n\n    const {revoke, proxy} = Array.isArray(base)\n        ? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n          // although state itself is an object\n          Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n\n    state.draft = proxy\n    state.revoke = revoke\n\n    scope.drafts.push(proxy)\n    return proxy\n}\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty() {\n        throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\") // prettier-ignore\n    },\n    getPrototypeOf(target) {\n        return Object.getPrototypeOf(target.base)\n    },\n    setPrototypeOf() {\n        throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\") // prettier-ignore\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop))) {\n        throw new Error(\"Immer only supports deleting array indices\") // prettier-ignore\n    }\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop))) {\n        throw new Error(\"Immer only supports setting array indices and the 'length' property\") // prettier-ignore\n    }\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\n// returns the object we should be reading the current value from, which is base, until some change has been made\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    if (prop === DRAFT_STATE) return state\n    let {drafts} = state\n\n    // Check for existing draft in unmodified state.\n    if (!state.modified && has(drafts, prop)) {\n        return drafts[prop]\n    }\n\n    const value = source(state)[prop]\n    if (state.finalized || !isDraftable(value)) return value\n\n    // Check for existing draft in modified state.\n    if (state.modified) {\n        // Assigned values are never drafted. This catches any drafts we created, too.\n        if (value !== state.base[prop]) return value\n        // Store drafts on the copy (when one exists).\n        drafts = state.copy\n    }\n\n    return (drafts[prop] = createProxy(value, state))\n}\n\nfunction set(state, prop, value) {\n    if (!state.modified) {\n        // Optimize based on value's truthiness. Truthy values are guaranteed to\n        // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n        // values may be drafts, but falsy values are never drafts.\n        const isUnchanged = value\n            ? is(state.base[prop], value) || value === state.drafts[prop]\n            : is(state.base[prop], value) && prop in state.base\n        if (isUnchanged) return true\n        markChanged(state)\n    }\n    state.assigned[prop] = true\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (state.base[prop] !== undefined || prop in state.base) {\n        state.assigned[prop] = false\n        markChanged(state)\n    }\n    if (state.copy) delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = source(state)\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (desc) {\n        desc.writable = true\n        desc.configurable = !Array.isArray(owner) || prop !== \"length\"\n    }\n    return desc\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = assign(shallowCopy(state.base), state.drafts)\n        state.drafts = null\n        if (state.parent) markChanged(state.parent)\n    }\n}\n","import {each} from \"./common\"\n\nexport function generatePatches(state, basePath, patches, inversePatches) {\n    Array.isArray(state.base)\n        ? generateArrayPatches(state, basePath, patches, inversePatches)\n        : generateObjectPatches(state, basePath, patches, inversePatches)\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n    let {base, copy, assigned} = state\n\n    // Reduce complexity by ensuring `base` is never longer.\n    if (copy.length < base.length) {\n        ;[base, copy] = [copy, base]\n        ;[patches, inversePatches] = [inversePatches, patches]\n    }\n\n    const delta = copy.length - base.length\n\n    // Find the first replaced index.\n    let start = 0\n    while (base[start] === copy[start] && start < base.length) {\n        ++start\n    }\n\n    // Find the last replaced index. Search from the end to optimize splice patches.\n    let end = base.length\n    while (end > start && base[end - 1] === copy[end + delta - 1]) {\n        --end\n    }\n\n    // Process replaced indices.\n    for (let i = start; i < end; ++i) {\n        if (assigned[i] && copy[i] !== base[i]) {\n            const path = basePath.concat([i])\n            patches.push({\n                op: \"replace\",\n                path,\n                value: copy[i]\n            })\n            inversePatches.push({\n                op: \"replace\",\n                path,\n                value: base[i]\n            })\n        }\n    }\n\n    const useRemove = end != base.length\n    const replaceCount = patches.length\n\n    // Process added indices.\n    for (let i = end + delta - 1; i >= end; --i) {\n        const path = basePath.concat([i])\n        patches[replaceCount + i - end] = {\n            op: \"add\",\n            path,\n            value: copy[i]\n        }\n        if (useRemove) {\n            inversePatches.push({\n                op: \"remove\",\n                path\n            })\n        }\n    }\n\n    // One \"replace\" patch reverses all non-splicing \"add\" patches.\n    if (!useRemove) {\n        inversePatches.push({\n            op: \"replace\",\n            path: basePath.concat([\"length\"]),\n            value: base.length\n        })\n    }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n    const {base, copy} = state\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = base[key]\n        const value = copy[key]\n        const op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\"\n        if (origValue === value && op === \"replace\") return\n        const path = basePath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                ? {op: \"add\", path, value: origValue}\n                : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        const {path} = patch\n        if (path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            let base = draft\n            for (let i = 0; i < path.length - 1; i++) {\n                base = base[path[i]]\n                if (!base || typeof base !== \"object\")\n                    throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n            }\n            const key = path[path.length - 1]\n            switch (patch.op) {\n                case \"replace\":\n                    base[key] = patch.value\n                    break\n                case \"add\":\n                    if (Array.isArray(base)) {\n                        // TODO: support \"foo/-\" paths for appending to an array\n                        base.splice(key, 0, patch.value)\n                    } else {\n                        base[key] = patch.value\n                    }\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        base.splice(key, 1)\n                    } else {\n                        delete base[key]\n                    }\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","import * as legacyProxy from \"./es5\"\nimport * as modernProxy from \"./proxy\"\nimport {applyPatches, generatePatches} from \"./patches\"\nimport {\n    assign,\n    each,\n    has,\n    is,\n    isDraft,\n    isDraftable,\n    isEnumerable,\n    shallowCopy,\n    DRAFT_STATE,\n    NOTHING\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\nfunction verifyMinified() {}\n\nconst configDefaults = {\n    useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n    autoFreeze:\n        typeof process !== \"undefined\"\n            ? process.env.NODE_ENV !== \"production\"\n            : verifyMinified.name === \"verifyMinified\",\n    onAssign: null,\n    onDelete: null,\n    onCopy: null\n}\n\nexport class Immer {\n    constructor(config) {\n        assign(this, configDefaults, config)\n        this.setUseProxies(this.useProxies)\n        this.produce = this.produce.bind(this)\n    }\n    produce(base, recipe, patchListener) {\n        // curried invocation\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\n            const defaultBase = recipe\n            recipe = base\n\n            // prettier-ignore\n            return (base = defaultBase, ...args) =>\n                this.produce(base, draft => recipe.call(draft, draft, ...args))\n        }\n\n        // prettier-ignore\n        {\n            if (typeof recipe !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n            if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n        }\n\n        let result\n\n        // Only plain objects, arrays, and \"immerable classes\" are drafted.\n        if (isDraftable(base)) {\n            const scope = ImmerScope.enter()\n            const proxy = this.createProxy(base)\n            let hasError = true\n            try {\n                result = recipe.call(proxy, proxy)\n                hasError = false\n            } finally {\n                // finally instead of catch + rethrow better preserves original stack\n                if (hasError) scope.revoke()\n                else scope.leave()\n            }\n            if (result instanceof Promise) {\n                return result.then(\n                    result => {\n                        scope.usePatches(patchListener)\n                        return this.processResult(result, scope)\n                    },\n                    error => {\n                        scope.revoke()\n                        throw error\n                    }\n                )\n            }\n            scope.usePatches(patchListener)\n            return this.processResult(result, scope)\n        } else {\n            result = recipe(base)\n            if (result === undefined) return base\n            return result !== NOTHING ? result : undefined\n        }\n    }\n    createDraft(base) {\n        if (!isDraftable(base)) throw new Error(\"First argument to createDraft should be a plain object, an array, or an immerable object.\") // prettier-ignore\n        const scope = ImmerScope.enter()\n        const proxy = this.createProxy(base)\n        scope.leave()\n        proxy[DRAFT_STATE].customDraft = true\n        return proxy\n    }\n    finishDraft(draft, patchListener) {\n        if (!isDraft(draft)) throw new Error(\"First argument to finishDraft should be an object from createDraft.\") // prettier-ignore\n        const state = draft[DRAFT_STATE]\n        if (!state.customDraft) throw new Error(\"The draft provided was not created using `createDraft`\") // prettier-ignore\n        if (state.finalized) throw new Error(\"The draft provided was has already been finished\") // prettier-ignore\n        // TODO: check if created with createDraft\n        // TODO: check if not finsihed twice\n        const {scope} = state\n        scope.usePatches(patchListener)\n        return this.processResult(undefined, scope)\n    }\n    setAutoFreeze(value) {\n        this.autoFreeze = value\n    }\n    setUseProxies(value) {\n        this.useProxies = value\n        assign(this, value ? modernProxy : legacyProxy)\n    }\n    applyPatches(base, patches) {\n        // Mutate the base state when a draft is passed.\n        if (isDraft(base)) {\n            return applyPatches(base, patches)\n        }\n        // Otherwise, produce a copy of the base state.\n        return this.produce(base, draft => applyPatches(draft, patches))\n    }\n    /** @internal */\n    processResult(result, scope) {\n        const baseDraft = scope.drafts[0]\n        const isReplaced = result !== undefined && result !== baseDraft\n        this.willFinalize(scope, result, isReplaced)\n        if (isReplaced) {\n            if (baseDraft[DRAFT_STATE].modified) {\n                scope.revoke()\n                throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n            }\n            if (isDraftable(result)) {\n                // Finalize the result in case it contains (or is) a subset of the draft.\n                result = this.finalize(result, null, scope)\n            }\n            if (scope.patches) {\n                scope.patches.push({\n                    op: \"replace\",\n                    path: [],\n                    value: result\n                })\n                scope.inversePatches.push({\n                    op: \"replace\",\n                    path: [],\n                    value: baseDraft[DRAFT_STATE].base\n                })\n            }\n        } else {\n            // Finalize the base draft.\n            result = this.finalize(baseDraft, [], scope)\n        }\n        scope.revoke()\n        if (scope.patches) {\n            scope.patchListener(scope.patches, scope.inversePatches)\n        }\n        return result !== NOTHING ? result : undefined\n    }\n    /**\n     * @internal\n     * Finalize a draft, returning either the unmodified base state or a modified\n     * copy of the base state.\n     */\n    finalize(draft, path, scope) {\n        const state = draft[DRAFT_STATE]\n        if (!state) {\n            if (Object.isFrozen(draft)) return draft\n            return this.finalizeTree(draft, null, scope)\n        }\n        // Never finalize drafts owned by another scope.\n        if (state.scope !== scope) {\n            return draft\n        }\n        if (!state.modified) {\n            return state.base\n        }\n        if (!state.finalized) {\n            state.finalized = true\n            this.finalizeTree(state.draft, path, scope)\n\n            if (this.onDelete) {\n                // The `assigned` object is unreliable with ES5 drafts.\n                if (this.useProxies) {\n                    const {assigned} = state\n                    for (const prop in assigned) {\n                        if (!assigned[prop]) this.onDelete(state, prop)\n                    }\n                } else {\n                    const {base, copy} = state\n                    each(base, prop => {\n                        if (!has(copy, prop)) this.onDelete(state, prop)\n                    })\n                }\n            }\n            if (this.onCopy) {\n                this.onCopy(state)\n            }\n\n            // At this point, all descendants of `state.copy` have been finalized,\n            // so we can be sure that `scope.canAutoFreeze` is accurate.\n            if (this.autoFreeze && scope.canAutoFreeze) {\n                Object.freeze(state.copy)\n            }\n\n            if (path && scope.patches) {\n                generatePatches(\n                    state,\n                    path,\n                    scope.patches,\n                    scope.inversePatches\n                )\n            }\n        }\n        return state.copy\n    }\n    /**\n     * @internal\n     * Finalize all drafts in the given state tree.\n     */\n    finalizeTree(root, rootPath, scope) {\n        const state = root[DRAFT_STATE]\n        if (state) {\n            if (!this.useProxies) {\n                state.finalizing = true\n                state.copy = shallowCopy(state.draft, true)\n                state.finalizing = false\n            }\n            root = state.copy\n        }\n\n        const needPatches = !!rootPath && !!scope.patches\n        const finalizeProperty = (prop, value, parent) => {\n            if (value === parent) {\n                throw Error(\"Immer forbids circular references\")\n            }\n\n            // In the `finalizeTree` method, only the `root` object may be a draft.\n            const isDraftProp = !!state && parent === root\n\n            if (isDraft(value)) {\n                const path =\n                    isDraftProp && needPatches && !state.assigned[prop]\n                        ? rootPath.concat(prop)\n                        : null\n\n                // Drafts owned by `scope` are finalized here.\n                value = this.finalize(value, path, scope)\n\n                // Drafts from another scope must prevent auto-freezing.\n                if (isDraft(value)) {\n                    scope.canAutoFreeze = false\n                }\n\n                // Preserve non-enumerable properties.\n                if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n                    parent[prop] = value\n                } else {\n                    Object.defineProperty(parent, prop, {value})\n                }\n\n                // Unchanged drafts are never passed to the `onAssign` hook.\n                if (isDraftProp && value === state.base[prop]) return\n            }\n            // Unchanged draft properties are ignored.\n            else if (isDraftProp && is(value, state.base[prop])) {\n                return\n            }\n            // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n            else if (isDraftable(value) && !Object.isFrozen(value)) {\n                each(value, finalizeProperty)\n            }\n\n            if (isDraftProp && this.onAssign) {\n                this.onAssign(state, prop, value)\n            }\n        }\n\n        each(root, finalizeProperty)\n        return root\n    }\n}\n","import {Immer} from \"./immer\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce = immer.produce\nexport default produce\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\nexport {\n    original,\n    isDraft,\n    isDraftable,\n    NOTHING as nothing,\n    DRAFTABLE as immerable\n} from \"./common\"\n\nexport {Immer}\n"],"names":["NOTHING","Symbol","DRAFTABLE","for","DRAFT_STATE","isDraft","value","isDraftable","Array","isArray","proto","Object","getPrototypeOf","prototype","constructor","original","base","assign","target","key","has","ownKeys","Reflect","getOwnPropertySymbols","getOwnPropertyNames","obj","concat","shallowCopy","invokeGetters","slice","clone","create","forEach","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","defineProperty","each","cb","i","length","isEnumerable","prop","thing","hasOwnProperty","is","x","y","ImmerScope","parent","drafts","canAutoFreeze","patches","patchListener","inversePatches","leave","revoke","current","enter","draft","descriptors","willFinalize","scope","result","isReplaced","finalizing","createProxy","clonePotentialDraft","state","push","revoked","source","copy","set","assigned","modified","markChanged","prepareCopy","proxyProperty","assertUnrevoked","JSON","stringify","markChangesSweep","hasArrayChanges","hasObjectChanges","markChangesRecursively","object","keys","undefined","descriptor","createHiddenProperty","revocable","arrayTraps","Proxy","objectTraps","proxy","fn","arguments","apply","deleteProperty","isNaN","parseInt","finalized","isUnchanged","owner","writable","configurable","generatePatches","basePath","generateArrayPatches","generateObjectPatches","delta","start","end","path","useRemove","replaceCount","assignedValue","origValue","op","applyPatches","patch","join","splice","verifyMinified","configDefaults","process","env","NODE_ENV","name","Immer","config","setUseProxies","useProxies","produce","bind","recipe","defaultBase","args","hasError","Promise","then","usePatches","processResult","error","customDraft","autoFreeze","modernProxy","legacyProxy","baseDraft","finalize","isFrozen","finalizeTree","onDelete","onCopy","freeze","root","rootPath","needPatches","finalizeProperty","isDraftProp","onAssign","immer","setAutoFreeze","createDraft","finishDraft"],"mappings":"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"}
